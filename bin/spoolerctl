#!/usr/bin/env python
# -*- coding: utf-8 -*-
# $Id$
#
# Copyright (c) 2007-2011 Otto-von-Guericke-UniversitÃ¤t, Magdeburg
#
# This file is part of ECSpooler.
#
"""
This module contains functions to start/stop the spooler or get status 
information from the spooler.  __main__ reads the command line 
arguments and processes them.
"""

import os, sys, time, signal, socket, xmlrpclib, getopt, atexit
import traceback
import logging

# add parent directory to the system path
sys.path.append(os.path.join(os.path.abspath(os.path.dirname(__file__)), os.pardir))

# local imports
import config
from lib.util import settings

settings.init_logging(format=config.LF_SHORT)
log = logging.getLogger('spoolerctl')

from lib.Spooler import Spooler

# Run process as nobody
try:
    os.setuid(settings.NOBODY_UID)
except os.error, e:
    log.warn("Cannot change uid: %s" % e)
    #print >> sys.stderr, "Cannot change uid:", e

LOCALHOST = '0.0.0.0'#socket.getfqdn(name)

def _startSpooler(port, pwdFile):
    """
    Starts the spooler process at localhost only.
    """
    
    host = LOCALHOST
    
    log.info("Starting spooler service at %s" % time.asctime()) 
    log.info("    Hostname: %s" % host)
    log.info("    Port: %i" % port)

    try:
        if sys.platform in ['unixware7']:
            cpid = os.fork1()
        else:
            cpid = os.fork()
    except AttributeError:
        log.warn('os.fork not defined - skipping it.')
        cpid = 0

    if cpid == 0:
        # child process
        for handler in logging._handlerList:
            if not isinstance(handler, logging.FileHandler):
                logging.getLogger().removeHandler(handler)
            # end if
        #end for
        
        spooler = Spooler(host, int(port), pwdFile)
        __tmp = spooler.start() # blocks 'til shutdown
        if __tmp:
            log.error(__tmp)
            
    else:
        # parent process
        time.sleep(1)
        log.info('pid=%d' % cpid)
        #print 'pid=%d' % cpid


def _stopSpooler(port, auth):
    """
    Stops a running spooler at localhost only.  We will get the PID
    from the status information and then send a kill to this process.
    """
    try:
        host = LOCALHOST
        
        log.info("Stopping spooler service at %s:%d" % (host, port))

        spooler = xmlrpclib.ServerProxy("http://%s:%s" % (host, port))
        status = spooler.getStatus(auth)
        
        if status:
            if status[0] > 0:

                try:
                    # stops the spooler sending kill -15 process-id
                    pid = status[1]['pid']
                    os.kill(pid, signal.SIGTERM)
                except AttributeError:
                    log.warn('os.kill and/or signal.SIGTERM not defined. '
                             'Trying to stop spooler elsewhere.')

            else:
                log.warn(status[1])
        else:
            log.warn("ECSpooler not responding (%s:%s)" % (host, port))

    except Exception, e: 
        log.warn("Unable to stop ECSpooler on %s:%d - %s:%s" % \
                 (host, port, sys.exc_info()[0], e))
        
        #log.debug(traceback.format_exc())
        #print "Unable to stop ECSpooler on %s:%d - %s:%s" % (host, port, sys.exc_info()[0], e)


def _getSpoolerStatus(host, port, auth):
    """
    Returns status information from a running spooler
    """
    
    try:
        spooler = xmlrpclib.Server("http://%s:%s" % (host, port))
        status = spooler.getStatus(auth)
            
        if status:
            if status[0] > 0:
                return status[1]
            else:
                log.warn(status[1])
        else:
            log.warn("ECSpooler not responding (%s:%s)" % (host, port))

    except Exception, e: 
        log.warn("Unable to get status information from ECSpooler (%s:%d) - %s:%s" % 
                 (host, port, sys.exc_info()[0], e))
    
    return ''


#def _removeBackend(host, port, auth, backendId):
#    """
#    Remove a backend from the list of registered backends.  Does *not* stop
#    the backend.  This is only intended for situations where the backend is
#    unreachable (e.g., it crashed).
#    """
#    try:
#        spooler = xmlrpclib.Server("http://%s:%s" % (host, port))
#        result = spooler.removeBackend(auth, backendId.lower())
#    
#        if result:
#            if result[0] > 0:
#                return result[1]
#            else:
#                log.warn(result[1])
#        else:
#            log.warn("ECSpooler not responding (%s:%s)" % (host, port))
#
#    except Exception, e: 
#        log.warn("Unable to remove backend from ECSpooler on %s:%d - %s:%s" % \
#                 (host, port, sys.exc_info()[0], e))
    

def usage():
    print """
Usage:  spoolerctl [OPTION ...] {start|stop|restart|status}

OPTIONs are:
  -H host         Hostname or IP to connect to; for status command only.  Default: localhost
  -P port         Port to connect/bind to.  Default: 5050
  -u user         Name of the user required for authentication when executing 
                  stop|restart|status command
  -p password     Password of the user required for authentication when
                  executing stop|restart|status command
  -a authfile     File to use to lookup the password for the given user.  The
                  file contains one 'user:password' entry per line.  This
                  option should be used instead of the -p option to avoid
                  exposing the password to every user on the system (e.g., via
                  ps -ef, pargs, etc.).
"""


def authError(cmd):
    print "Command '%s' requires username and password." % cmd


def getPassFromFile(file, user):
    """
    Read the given file of user:password entries and return the password
    for the given user if found.
			@return: None if the given file does not exist or has no entry
             for the given user, the users' password otherwise.
    """

    if not os.path.exists(file):
        log.warn("Unable to read '%s'" % (file))
        return None

    lines = []
    try:
        pwdFile = open(file, "r")
        lines = pwdFile.readlines()
        pwdFile.close()
        
    except IOError, ioe:
        log.warn("Error reading file '%s': %s" % (file, ioe));
        #print "Error reading file '%s': %s" % (file, ioe)
        return None

    for line in lines:
        if line.startswith("#"): continue
        if not line.strip(): continue
        _tmp = line.split(':', 2)
        if len(_tmp) == 2 and _tmp[0] == user:
            return _tmp[1]

    return None
            

def main():    
    """
    """
    try:
        opts, args = getopt.getopt(sys.argv[1:], "H:P:u:p:a:h", 
                                   ["host=", "port=", "user=", "password=",
                                    "authfile=", "help"])
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(2)

    host = None
    port = None
    user = None
    password = None
    authfile = None
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

        if o in ("-H", "--host"):
            host = a

        if o in ("-P", "--port"):
            try:
                port = int(a)
            except ValueError:
                usage()
                sys.exit(2)
                
        if o in ("-u", "--user"):
            user = a

        if o in ("-p", "--password"):
            password = a

        if o in ("-a", "--authfile"):
            authfile = a

    
    if len(args) == 0:
        usage()
        sys.exit(2)

    else:
        command = args[0]
        
        if not host: host = LOCALHOST
        if not port: port = 5050
        
        if authfile and user:
            _pw = getPassFromFile(authfile, user)
            if _pw:
                password = _pw

        pwdFile = os.path.join(os.path.dirname(__file__), '..', 'etc', 'passwd')
        
        try:
            if command == 'start':
                settings.init_logging(fname="spooler")
                _startSpooler(port, pwdFile)

            else:
                if not user or not password:
                    authError(command)
                    usage()
                    sys.exit(2)
                else:
                    auth = {"username":user, "password":password}
    
                    if command == 'stop':
                        _stopSpooler(port, auth)
                    elif command == 'restart':
                        _stopSpooler(port, auth)
                        time.sleep(3)
                        settings.init_logging(fname="spooler")
                        _startSpooler(port, pwdFile)
                    elif command == 'status':
                        print _getSpoolerStatus(host, port, auth)

                    #elif command == 'rmbackend':
                    #    if len(args) < 2:
                    #        print 'rmbackend needs a backend ID'
                    #        sys.exit(2)
                    #    _removeBackend(host, port, auth, args[1])
                    
                    else:
                        print 'Unknown command %s' % command
                        usage()
                        sys.exit(2)

        except (socket.error, xmlrpclib.Fault), exc:
            log.error("Server - %s: %s" % (sys.exc_info()[0], exc))
            #traceback.print_exc()
            #print type(exc)     # the exception instance
            #print exc.args      # arguments stored in .args
            #print exc           # __str__ allows args to printed directly
            #print sys.exc_info()[0]
            #print >> sys.stderr, "Server - %s: %s" % (sys.exc_info()[0], exc)

        except Exception, e:
            log.error("%s: %s" % (sys.exc_info()[0], e))
            #traceback.print_exc()
            #print type(e)     # the exception instance
            #print e.args      # arguments stored in .args
            #print e           # __str__ allows args to printed directly
            #print sys.exc_info()[0]
            #print >> sys.stderr, "%s: %s" % (sys.exc_info()[0], e)


# -- Main ----------------------------------------------------------------------
if __name__ == "__main__":
    main()
            
