#!/usr/bin/env python
# -*- coding: utf-8 -*-
# $Id$
#
# Copyright (c) 2007 Otto-von-Guericke-UniversitÃ¤t, Magdeburg
#
# This file is part of ECSpooler.

"""
This module contains functions to start/stop the spooler or get status 
information from the spooler.  __main__ reads the command lines 
arguments and processes them.
"""

import os, sys, time, signal, socket, xmlrpclib, getopt, tempfile
import traceback
import logging

# add parent directory to the system path
sys.path.append(os.path.join(os.path.abspath(os.path.dirname(__file__)), os.pardir))
log = None

def _startSpooler(host, port, pwdFile):
    """
    """
    log.info("Starting spooler on %s port %d ..." % (host, port))
    print "INFO: Starting spooler on %s port %d ..." % (host, port)

    try:
        if sys.platform in ['unixware7']:
            cpid = os.fork1()
        else:
            cpid = os.fork()
    except AttributeError, aerr:
        log.warn('os.fork not defined - skipping.')
        cpid = 0

    if cpid == 0:
        # child process
        #import Spooler

        spooler = Spooler(host, int(port), pwdFile)
        spooler.start()
    else:
        # parent process
        time.sleep(1)
        print 'INFO: pid=%d' % cpid


def _stopSpooler(host, port, auth):
    """
    """
    try:
        log.info("Stopping ECSpooler on %s:%d ..." % (host, port))
        print "INFO: Stopping ECSpooler on %s:%d ..." % (host, port)

        spooler = xmlrpclib.ServerProxy("http://%s:%s" % (host, port))
        pid = spooler.getStatus(auth)[1]['pid']
        
        # TODO: THIS FLAW IS VERY DANGEROUS (if the remote host returns a pid
        # which accidently matches a pid on the localhost)
        # Actually the spooler should shutdown itself on message
        if host == 'localhost':
            try:
                # stops the spooler sending kill -15 process-id
                os.kill(pid, signal.SIGTERM)         
            except AttributeError:
                log.warn('os.kill and/or signal.SIGTERM not defined. '
                          'Trying to stop spooler elsewhere.')
            # FIXME:
            #spooler.shutdown(auth)
        else
            print "ERROR: remote shutdown not supported"

    except Exception, e: 
        print "WARNING: %s: %s" % (sys.exc_info()[0], e)
        log.warn("Unable to stop ECSpooler on %s:%d" % (host, port))
        print "WARNING: Unable to stop ECSpooler on %s:%d" % (host, port)
        if LOGLEVEL == logging.DEBUG:
            traceback.print_exc()
        pass


def _getSpoolerStatus(host, port, auth):
    """
    """
    spooler = xmlrpclib.Server("http://%s:%s" % (host, port))
    return spooler.getStatus(auth)[1]


def _removeBackend(host, port, auth, backendId):
    """
    Remove a backend from the list of registered backends.  Does *not* stop
    the backend.  This is only intended for situations where the backend is
    unreachable (e.g., it crashed).
    """
    spooler = xmlrpclib.Server("http://%s:%s" % (host, port))
    return spooler.removeBackend(auth, backendId.lower())
    

def usage():
    print """
Usage:  spoolerctl [OPTION ...] {start|stop|restart|status}

OPTIONs are:
  -t dir          Directory to use for temporary files.  If not specified, the
                  OS default TMPDIR will be used.
                  Sets the environment variable TMPDIR to the given value.
  -v dir          Directory where to store jobs and results.
                  Default: INSTALLDIR/var/
                  Sets the environment variable VARDIR to the given value.
  -w dir          Direcotry to use as working directory.  Default: current
                  working directory.
  -L dir          Directory where to store logs.  Default: INSTALLDIR/log
                  Sets the environment variable LOGDIR to the given value.
  -l loglevel     LogLevel to use: {FATAL|ERROR|WARN|INFO|DEBUG|NONE}. 
                  Sets the environment variable LOGLEVEL to the given value.
  -H host         Hostname or IP to connect/bind to.  Default: localhost
  -P port         Port to connect/bind to.  Default: 5050
  -u user         Name of the user required for authentication when executing 
                  stop|restart|status command
  -p password     Password of the user required for authentication when
                  executing stop|restart|status command
  -a authfile     File to use to lookup the password for the given user.  The
                  file contains one 'user:password' entry per line.  This
                  option should be used instead of the -p option to avoid
                  exposing the password to every user on the system (e.g. via
                  ps -ef, pargs etc.).
"""


def authError(cmd):
    print "ERROR: Command '%s' requires username and password." % cmd

def getPassFromFile(file, user):
    """
    Read the given file of user:password entries and return the password
    for the given user if found.
			@return: None if the given file does not exist or has no entry
             for the given user, the users' password otherwise.
    """

    if not os.path.exists(file):
        print "WARNING: Unable to read '%s'" % (file)
        return None

    lines = []
    try:
        pwdFile = open(file, "r")
        lines = pwdFile.readlines()
        pwdFile.close()
    except IOError, ioe:
        print "WARNING: Error when reading file '%s': %s" % (file, ioe);
        return None

    for line in lines:
        if line.startswith("#"): continue
        if not line.strip(): continue
        _tmp = line.split(':', 2)
        if len(_tmp) == 2 and _tmp[0] == user:
            return _tmp[1]

    return None
            

def main():    
    """
    """
    try:
        opts, args = getopt.getopt(sys.argv[1:], "l:t:w:v:L:H:P:u:p:a:h", 
                     ["loglevel=", "tmpdir=", "workdir=", "vardir=", "logdir=",
                      "host=", "port=", "user=", "password=", "authfile=",
                      "help"])
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(2)

    host = None
    port = None
    user = None
    password = None
    tmpdir = None
    workdir = None
    authfile = None

    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

        if o in ("-H", "--host"):
            host = a

        if o in ("-P", "--port"):
            try:
                port = int(a)
            except ValueError:
                usage()
                sys.exit(2)
                
        if o in ("-u", "--user"):
            user = a

        if o in ("-p", "--password"):
            password = a

        if o in ("-l", "--loglevel"):
            os.environ['LOGLEVEL'] = a

        if o in ("-t", "--tmpdir"):
            if not a == "default":
                tmpdir = a;

        if o in ("-L", "--logdir"):
            if not a == "default":
                os.environ['LOGDIR'] = a

        if o in ("-v", "--vardir"):
            if not a == "default":
                os.environ['VARDIR'] = a

        if o in ("-w", "--workdir"):
            if not a == "default":
                workdir = a

        if o in ("-a", "--authfile"):
            authfile = a

    if len(args) == 0:
        usage()
        sys.exit(2)

    else:
        command = args[0]
        
        """ Q&D: Prevent initializing backend stuff in config.py """
        os.environ['EC_SRVC'] = "SPOOLER";

        global Spooler, LOGLEVEL;
        from config import LOGLEVEL, NOBODY_UID, NOBODY_GID
        from lib.Spooler import Spooler
        
        # get logger
        global log
        log = logging.getLogger('lib.Spooler')
        
        # Run process as nobody if we are root
        if os.geteuid() == 0:
            try:
                os.setuid(NOBODY_UID)
            except os.error, e:
                log.warn("Cannot change uid: %s" % e)
                print >> sys.stderr, "WARNING: Cannot change uid:", e
        
        if not host: host = 'localhost' #socket.getfqdn()
        if not port: port = 5050
        if tmpdir:
            os.environ['TMPDIR'] = tmpdir
            if not os.path.exists(tmpdir):
                try:
                    os.mkdir(tmpdir)
                except Exception, e:
                    print "WARNING: Unable to create directory: %s - using the default '%s' instead" % (e, tempfile.gettempdir())

            if os.geteuid() != 0 and tmpdir == tempfile.gettempdir():
                """ Too much trouble one could cause as root """
                try:
                    os.chmod(tmpdir, 0700)
                except Exception, e:
                    print "WARNING: Unable to chmod 0770 %s: %s" % (tmpdir, e)

        if workdir:
            try:
                os.chdir(workdir)
            except Exception, e:
                print "WARNING: Unable to change working directory to '%s': %s" % (e, workdir)

        if authfile and user:
            _pw = getPassFromFile(authfile, user)
            if _pw:
                password = _pw
            
        pwdFile = os.path.join(os.path.dirname(__file__),
                               '..', 'etc', 'passwd')
        
        try:
            if command == 'start':
                _startSpooler(host, port, pwdFile)
    
            else:
                if not user or not password:
                    authError(command)
                    usage()
                    sys.exit(2)
                else:
                    auth = {"username":user, "password":password}
                
                    if command == 'stop':
                        _stopSpooler(host, port, auth)
    
                    elif command == 'restart':
                        _stopSpooler(host, port, auth)
                        time.sleep(3)
                        _startSpooler(host, port, pwdFile)
    
                    elif command == 'status':
                        print _getSpoolerStatus(host, port, auth)

                    elif command == 'rmbackend':
                        if len(args) < 2:
                            print 'ERROR: rmbackend needs a backend ID'
                            sys.exit(2)
                        print _removeBackend(host, port, auth, args[1])
    
                    else:
                        print 'ERROR: Unknown command %s' % command
                        usage()

        except (socket.error, xmlrpclib.Fault), exc:
            if LOGLEVEL == logging.DEBUG:
                traceback.print_exc()
                #print type(exc)     # the exception instance
                #print exc.args      # arguments stored in .args
                #print exc           # __str__ allows args to printed directly
                #print sys.exc_info()[0]

            print "ERRROR: Server - %s: %s" % (sys.exc_info()[0], exc)

        except Exception, e:
            if LOGLEVEL == logging.DEBUG:
                traceback.print_exc()
                #print type(e)     # the exception instance
                #print e.args      # arguments stored in .args
                #print e           # __str__ allows args to printed directly
                #print sys.exc_info()[0]

            print "ERROR: %s: %s" % (sys.exc_info()[0], e)


# -- Main ----------------------------------------------------------------------
if __name__ == "__main__":
    main()
