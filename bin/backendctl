#!/usr/bin/env python
# -*- coding: utf-8 -*-
# $Id$
#
# Copyright (c) 2007 Otto-von-Guericke-UniversitÃ¤t, Magdeburg
#
# This file is part of ECSpooler.

"""
This module contains functions to start/stop a backend or get status 
information from a backend. __main__ reads the command lines arguments and
processes them. A configuration file must be avaiable for each backend 
with entries about spooler server's host and port as well as base port 
for the backend. If a port is already in use, we will try another one.
"""

import os, sys, time, socket, xmlrpclib, tempfile
import traceback
import getopt
import logging

# add parent directory to the system path
sys.path.append(os.path.join(os.path.abspath(os.path.dirname(__file__)), os.pardir))
log = None

# TODO: should be in config.py
MAX_TRIALS = 15

def _startBackend(backendId, backendHost, backendPort, spoolerHost, spoolerPort,
                  spoolerAuth):
    """
    Starts a backend with the given parameters.
    """
    try:
        exec 'from backends.%s import %s' % (backendId.lower(), backendId)
        exec 'id = %s.%s.id' % (backendId, backendId,)
    except NameError, ne:
        print >> sys.stderr, "ERROR: No such backend: '%s'" % (backendId,)
        raise ne
    except AttributeError, ae:
        print >> sys.stderr, "ERROR: No such backend: '%s'.  Did you mean '%s'?" \
              % (backendId, backendId.capitalize(),)
        raise ae
    
    exec 'version = %s.%s.version' % (backendId, backendId,)

    log.info("Starting backend '%s %s (%s)' on %s..." % (backendId, version, id, backendHost))
    print "INFO: Starting backend '%s %s (%s)' on %s..." % (backendId, version, id, backendHost)

    try:
        if sys.platform in ['unixware7']:
            cpid = os.fork1()
        else:
            cpid = os.fork()
    except AttributeError, aerr:
        log.warn('os.fork not defined - skipping.')
        cpid = 0

    if cpid == 0:
        # child process
        (backend, p)= _getBackendInstance(backendId, backendHost, backendPort, 
                                     spoolerHost, spoolerPort, spoolerAuth)
        
        if backend:
            log.info('port=%d' % p)
            print 'INFO: port=%d' % p
            __tmp = backend.start()
            if __tmp:
                print "ERROR: " + __tmp
        else:
            print 'ERROR: Backend start finally failed. See log for more information.'

    else:
        # parent process
        time.sleep(1)
        print 'INFO: pid=%d' % cpid


def _getBackendInstance(backendId, backendHost, backendPort, spoolerHost, 
                        spoolerPort, spoolerAuth):
    """
    Returns an instance of the backend class if one could be created.
    """
    
    # put together the backend module and class name using backendId
    moduleName = '%s' % \
        backendId
        #(backendId.lower()[0].upper() + backendId.lower()[1:])
    moduleName = '%s.%s' % (backendId, backendId,)
    
    for i in range(backendPort, backendPort + MAX_TRIALS, 1):
    
        # get a instance, e.g., PythonBackend
        # FIXME: use spooler instead of spooler
        instanceCreateStmt = \
        "backend = %s({ \
                    'host': '%s', \
                    'port': %d, \
                    'spooler': 'http://%s:%d', \
                    'auth': %s}, %s.__file__)" \
                % (moduleName, backendHost, i, \
                   spoolerHost, spoolerPort, repr(spoolerAuth), backendId)
                
        retval = _tryGetBackendInstance(backendId, instanceCreateStmt)
        
        if retval: 
            return (retval, i)
        else:
            time.sleep(0.1)
    
    return None
    

def _tryGetBackendInstance(backendId, instanceCreateStmt):
    """
    Executes the import statement for the backend class, creates an instance 
    and returns this instance.
    
    An exception is thrown if the port is already in use. In this case we will
    return None.

    @param: backendId ID of the backend
    @param: instanceCreateStmt Statement which will be executed to create a new
                               instance of the backend class.
    @return: The backend instance or None if the instance couldn't be created.
    """
    try:
        log.debug("Trying to create instance of backend '%s'" % backendId)
        #log.debug(instanceCreateStmt)

        exec 'from backends.%s import %s' % (backendId.lower(), backendId)
        exec(instanceCreateStmt)

        return backend

    # FIXME: This doesn't work on Windows -> no socket.error is thrown if
    #        port is already in use!
    except socket.error, msg:
        return None
        

def _stopBackend(backendId, spoolerHost, spoolerPort, spoolerAuth):
    """
    Stops the backend.
    """
    exec 'from backends.%s import %s' % (backendId.lower(), backendId)

    exec 'from backends.%s import %s' % (backendId.lower(), backendId)
    exec 'id = %s.%s.id' % (backendId, backendId,)
    exec 'version = %s.%s.version' % (backendId, backendId,)
    
    log.info("Unregister backend '%s %s (%s)' on %s:%s ..." % (backendId,
             version, id, spoolerHost, spoolerPort))
    print "INFO: Unregister backend '%s %s (%s)' on %s:%s ..." % (backendId,
             version, id, spoolerHost, spoolerPort)

    spooler = xmlrpclib.ServerProxy("http://%s:%d" % (spoolerHost, spoolerPort))
    retval = spooler.stopBackend(spoolerAuth, id)
    
    if retval:
        if retval[0]:
            print 'INFO: Done.'
        else:
            print 'WARNING: ' + retval[1]


def _getStatus(backendId, spoolerHost, spoolerPort, spoolerAuth):
    """
    Returns some status information of the backend.
    """
    spooler = xmlrpclib.ServerProxy("http://%s:%d" % (spoolerHost, spoolerPort))
    result = spooler.getBackendStatus(spoolerAuth, backendId.lower())
    
    if result and result[0]:
        return result[1]
    else:
        return result


def usage():
    print """
Usage: backendctl [OPTION ...] BACKEND {start|stop|restart|status}

OPTIONs are:
  -t dir          Directory to use for temporary files.  If not specified, the
                  OS default TMPDIR will be used.
                  Sets the environment variable TMPDIR to the given value.
  -v dir          Directory where to store jobs and results. 
                  Default: INSTALLDIR/var/
                  Sets the environment variable VARDIR to the given value.
  -w dir          Direcotry to use as working directory.
                  Default: current working directory.
  -L dir          Directory where to store logs.  Default: INSTALLDIR/log
                  Sets the environment variable LOGDIR to the given value.
  -l loglevel     LogLevel to use: {FATAL|ERROR|WARN|INFO|DEBUG|NONE}.
                  Sets the environment variable LOGLEVEL to the given value.
  -i interpreter  Absolute path to the interpreter to use.  If specified, the
                  environment variable INTERPRETER is set to this value, so
                  that it can be used by wrapper scripts used by the backend.
  -c compiler     Absolute path to the compiler to use.  If specified, the
                  environment variable COMPILER is set to this value, so
                  that it can be used by wrapper scripts used by the backend.
  -T value        Sets the environment variable EC_TRACE to the given value,
                  which might be used to decide, which wrapper (tracer) should
                  run the actual task.  See backends/*Conf.py 
  -d              Don't cleanup the temporary files created when running a job.
  -H host         Hostname or IP of the machine to use to connect to the
                  spooler.  Default: localhost
  -P port         Port of the spooler to connect to.  Default: 5050
  -b hostname     Hostname or IP to bind to.  Default: localhost
  -B port         Port to bind to, i.e. where to listen for new request.
                  Default: First free port in the range of 5060 .. 5074.
  -u user         Name of the user required for authentication when executing
                  stop|restart|status command
  -p password     Password of the user required for authentication when
                  executing stop|restart|status command
  -a authfile     File to use to lookup the password for the given user.  The
                  file contains one 'user:password' entry per line.  This
                  option should be used instead of the -p option to avoid
                  exposing the password to every user on the system (e.g. via
                  ps -ef, pargs etc.).
  BACKEND         Name of the backend to start|stop|restart|status.
"""

def authError(cmd):
    print "ERROR: %s requires username and password" % cmd

def getPassFromFile(file, user):
    """
    Read the given file of user:password entries and return the password
    for the given user if found.
    @return: None if the given file does not exist or has no entry
             for the given user, the users' password otherwise.
    """

    if not os.path.exists(file):
        print "WARNING: Unable to read '%s'" % (file)
        return None

    lines = []
    try:
        pwdFile = open(file, "r")
        lines = pwdFile.readlines()
        pwdFile.close()
    except IOError, ioe:
        print "WARNING: Error when reading file '%s': %s" % (file, ioe);
        return None

    for line in lines:
        if line.startswith("#"): continue
        if not line.strip(): continue
        __tmp = line.split(':', 2)
        if len(__tmp) == 2 and __tmp[0] == user:
            return __tmp[1]

    return None

def main():
    """
    """

    try:
        opts, args = getopt.getopt(sys.argv[1:], 
                      "i:c:T:dl:t:w:v:L:H:P:u:p:a:B:b:h", 
                     ["interpreter=", "compiler=", "trace=", "debug",
                      "loglevel=", "tmpdir=", "workdir=", "vardir=", "logdir=",
                      "spoolerhost=", "spoolerport=", 
                      "user=", "password=", "authfile=", 
                      "backendport=", "backendhost=",
                      "help"])
    except getopt.GetoptError:
        # print help information and exit:
        usage()
        sys.exit(2)

    spoolerHost = None
    spoolerPort = None
    user = None
    password = None
    backendHost = None
    backendPort = None
    interpreter = None
    compiler = None
    tmpdir = None
    workdir = None
    authfile = None
    
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()

        if o in ("-H", "--spoolerhost"):
            spoolerHost = a

        if o in ("-P", "--spoolerport"):
            try:
                spoolerPort = int(a)
            except ValueError:
                usage()
                sys.exit(2)
                
        if o in ("-u", "--user"):
            user = a

        if o in ("-p", "--password"):
            password = a

        if o in ("-B", "--backendport"):
            try:
                backendPort = int(a)
            except ValueError:
                usage()
                sys.exit(2)
    
        if o in ("-b", "--backendhost"):
            backendHost = a

        if o in ("-i", "--interpreter"):
            interpreter = a

        if o in ("-c", "--compiler"):
            compiler = a

        if o in ("-d", "--debug"):
			os.environ['CLEANUP'] = False;

        if o in ("-l", "--loglevel"):
            os.environ['LOGLEVEL'] = a;

        if o in ("-t", "--tmpdir"):
            if not a == "default":
                tmpdir = a;

        if o in ("-L", "--logdir"):
            if not a == "default":
                os.environ['LOGDIR'] = a;

        if o in ("-v", "--vardir"):
            if not a == "default":
                os.environ['VARDIR'] = a;

        if o in ("-w", "--workdir"):
            if not a == "default":
                workdir = a

        if o in ("-a", "--authfile"):
            authfile = a

        if o in ("-T", "--trace"):
            os.environ['EC_TRACE'] = a


    if len(args) != 2:
        usage()
        sys.exit(2)

    else:
        backendId, cmd = args
        if authfile and user:
            __pw = getPassFromFile(authfile, user)
            if __pw:
                password = __pw

        auth = {"username":user, "password":password}
        """ Q&D: Prevent initializing spooler stuff in config.py """
        os.environ['EC_SRVC'] = backendId.lower()

		# TODO: cant't do that earlier since params need to be parsed first ...
        from config import LOGLEVEL, NOBODY_UID, NOBODY_GID
		# TODO: is this (originally even *) really required?
		# _startBackend seems to do that anyway
        __import__('backends.' + backendId.lower())
        
        # get logger
        global log
        log = logging.getLogger('lib.AbstractBackend')
        
        # Run process as nobody if we are root
        if os.geteuid() == 0:
            try:
                os.setuid(NOBODY_UID)
            except os.error, e:
                log.warn("Cannot change uid: %s" % e)
                print >> sys.stderr, "WARNING: Cannot change uid:", e

		# TODO: defaults should be part of config.py
        if not backendHost: backendHost = 'localhost'
        if not spoolerHost: spoolerHost = 'localhost' #socket.getfqdn()
        if not spoolerPort: spoolerPort = 5050
        if not backendPort: backendPort = 5060

        if compiler:
            if not os.path.exists(compiler):
                print "WARNING: compiler option ignored - '%s' does not exist" % (compiler)
            else:
                os.environ['COMPILER'] = compiler;

        if interpreter:
            if not os.path.exists(interpreter):
                print "WARNING: interpreter option ignored - '%s' does not exist" % (interpreter)
            else:
                os.environ['INTERPRETER'] = interpreter;

        if tmpdir:
            os.environ['TMPDIR'] = tmpdir
            if not os.path.exists(tmpdir):
                try:
                    os.mkdir(tmpdir)
                except Exception, e:
                    print "WARNING: Unable to create directory: %s - using the default '%s' instead" % (e, tempfile.gettempdir())

            if os.geteuid() != 0 and tmpdir == tempfile.gettempdir():
                """ Too much trouble one could cause doing this as root """
                try:
                    os.chmod(tmpdir, 0700)
                except Exception, e:
                    print "WARNING: Unable to chmod 0770 %s: %s" % (tmpdir, e)

        if workdir:
            try:
                os.chdir(workdir)
            except Exception, e:
                print "WARNING: Unable to change working directory to '%s': %s" % (e, workdir)

        if not user or not password:
            authError(cmd)
            usage()
            sys.exit(2)
        else:
            try:
                # check cmd option and do the indicated action
                if cmd == 'start':
                    _startBackend(backendId, backendHost, backendPort,
                                  spoolerHost, spoolerPort, auth)
    
                elif cmd == 'stop':
                    _stopBackend(backendId, spoolerHost, spoolerPort, auth)
                
                elif cmd == 'restart':
                    _stopBackend(backendId, spoolerHost, spoolerPort, auth)
                    time.sleep(2)
        
                    _startBackend(backendId, backendHost, backendPort,
                                  spoolerHost, spoolerPort, auth)

                elif cmd == 'status':
                    #raise NotImplementedError('Getting status information is ' +
                    #                          'not implemented yet.')
                    print _getStatus(backendId, spoolerHost, spoolerPort, auth)
    
                else:
                    print 'ERROR: Unknown command %s' % cmd
                    usage()
                    
            except Exception, e:
                if LOGLEVEL == logging.DEBUG:
                    traceback.print_exc()
                    #print type(e)     # the exception instance
                    #print e.args      # arguments stored in .args
                    #print e           # __str__ allows args to printed directly
                    #print sys.exc_info()[0]

                print "ERROR: %s: %s" % (sys.exc_info()[0], e)

# -- Main ----------------------------------------------------------------------
if __name__ == "__main__":
    main()
